CREATE OR REPLACE FUNCTION cita_changes()
RETURNS TRIGGER AS $$
DECLARE 
    id_cli INTEGER;
    start_dat DATE;
    v_start_slot_am TEXT := '09:00';  -- Example value for start AM time
    v_end_slot_am TEXT := '14:00';    -- Example value for end AM time
    v_start_slot_pm TEXT := '17:00';  -- Example value for start PM time
    v_end_slot_pm TEXT := '20:00';    -- Example value for end PM time
BEGIN
    -- Determine values based on the trigger event (INSERT or DELETE)
    IF TG_OP = 'INSERT' THEN
        id_cli := NEW.id_client;
        start_dat := NEW.start_date;
    ELSIF TG_OP = 'DELETE' THEN
        id_cli := OLD.id_client;
        start_dat := OLD.start_date;
    END IF;
    SELECT start_slot_am, end_slot_am, start_slot_pm, end_slot_pm 
    INTO v_start_slot_am, v_end_slot_am, v_start_slot_pm, v_end_slot_pm  
    FROM "CLIENT" 
    WHERE id = id_cli;

    DELETE FROM "AVAILABILITY" WHERE id_client = id_cli AND cur_date::DATE = start_dat;
    -- Insert available slots into "AVAILABILITY"
    INSERT INTO "AVAILABILITY" ("id_client", "cur_date", "slot")
    WITH RECURSIVE AllPossibleSlots AS (
        -- Generate all possible 15-minute slots for the selected date
        SELECT start_dat + INTERVAL '00:00:00' AS possible_slot
        UNION ALL
        SELECT possible_slot + INTERVAL '15 minutes'
        FROM AllPossibleSlots
        WHERE possible_slot + INTERVAL '15 minutes' < start_dat + INTERVAL '1 day'
    ),
    ExpandedSlots AS (
        -- Generate occupied time slots (15 min before, exact time, 15 min after)
        SELECT 
            cit.start_date,
            cit.start_date + (seq.seq - 2) * INTERVAL '15' MINUTE AS occupied_slot 
        FROM "CITA" cit
        CROSS JOIN (VALUES (1), (2), (3)) AS seq(seq)
    ),
    Final AS (
        -- Exclude occupied slots
        SELECT aps.possible_slot
        FROM AllPossibleSlots aps
        LEFT JOIN ExpandedSlots exp ON aps.possible_slot = exp.occupied_slot
        LEFT JOIN "CITA" cit ON aps.possible_slot = cit.start_date
        WHERE exp.occupied_slot IS NULL  -- Ensure slot is not occupied
        AND cit.start_date IS NULL
    )
   SELECT 
        id_cli,
        start_dat + possible_slot::TIME AS cur_date,
        TO_CHAR(possible_slot, 'HH24:MI') AS slot  -- Corrected TO_CHAR usage
    FROM Final
    WHERE 
        (possible_slot::TIME >= CAST(v_start_slot_am AS TIME) AND possible_slot::TIME < CAST(v_end_slot_am AS TIME))
        OR 
        (possible_slot::TIME >= CAST(v_start_slot_pm AS TIME) AND possible_slot::TIME < CAST(v_end_slot_pm AS TIME))
    ORDER BY possible_slot;

IF TG_OP = 'INSERT' THEN
    -- Add your logic here
    RAISE NOTICE 'New record inserted with id: %, created_at: %', NEW.id, NEW.created_at;
    -- Always return the NEW row after INSERT triggers
    RETURN NEW;
ELSIF TG_OP = 'DELETE' THEN
    -- Add your logic here
    RAISE NOTICE 'Record with id: % is about to be deleted', OLD.id;
    -- Always return the OLD row for BEFORE DELETE triggers
    RETURN OLD;  -- Deletion will happen unless you return NULL
END IF;
END;
$$ LANGUAGE plpgsql;
